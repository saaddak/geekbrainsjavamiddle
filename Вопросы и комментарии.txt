Комментарии:
Моих скромных познаний хватило лишь на то, чтобы закрывать поток при отключении пользователя в методе disconnect класса ClientGUI. При этом, сам сокет, насколько я могу судить, не закрывается и при том создаётся новый каждый раз при новом соединении. Как безопасно закрывать сокеты и нужно ли это делать в принципе в данной ситуации, я пока не знаю. Кроме того, я не уверен, безопасно ли закрывается текущий поток клиента.
Поведение элементов клиентской формы я реализовал не через скрытие, но через простое и глупое их отключение методом setEnabled.
После запуска сервера и клиента, а также его подключения, если закрыть затем окно клиента, на методе onSocketStop, переопределённом в классе ChatServer, возникает исключение SocketException: Connection reset, причину возникновения которого я понять не сумел. Возможно, это происходит из-за того, что с закрытием окна клиента не происходит нормального закрытия сокета и возникает исключение.
Вопросы:
1. Первый и главный вопрос: почему именно так? Почему такая архитектура и чем это обусловлено? Можно ли реализовать всё иначе и как? Быть может, есть уже отработанные пути решения этой задачи? Черезчур обширный вопрос, но он возник практически сразу и не покидает меня до сих пор.
2. При работе с асинхронностью резонно возникает вопрос, как обрабатывать случаи, когда клиент уже завершает работу, скажем, при помощи interrupt, но другие клиенты и сервер продолжают с ним активно обмениваться данными? Он постепенно завершает работу и после этого просто отваливается из обмена или следует вводить какие-то флаги состояний, которые выбрасываются в момент начала interrupt, чтобы оповестить других, что слать ему уже ничего не нужно?
3. Как я понимаю, клиент и сервер реализуют интерфейс SocketThreadListener, который позволяет им строить своё поведение в одной парадигме. Но мне пока сложно понять, как именно взаимодействуют ServerSocketThread и SocketThread c самим ChatServer? Моё понимание интерфейсов пока находится на уровне "классы реализуют интерфейсы". В ServerSocketThread и SocketThread же я вижу лишь наследование от класса Thread и создание некой ссылки на интерфейсы SocketThreadListener и ServerSocketThreadListener с последующим использованием методов, описанных в интерфейсе. Почему это реализованно именно так, на не через привычное "классы реализуют интерфейсы"?
